<?php
/**
 * @file
 * A description of what your module does.
 *
 *
 */


/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function webform_storage_toggle_form_webform_admin_settings_alter(&$form, $form_state) {
  // Add our config options to the webform settings page.
  $form['storage_toggle'] = array(
    '#type' => 'fieldset',
    '#title' => t('Webform Storage Options'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $null_flag = variable_get('webform_storage_toggle_null_flag');
  $form['storage_toggle']['webform_storage_toggle_null_flag'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable the use of a NULL value as a replacement'),
    '#default_value' => $null_flag ? $null_flag : 0,
    '#description' => t('<p>When the storage toggle to obfuscate the field\'s submission is set, make that value NULL. This will ensure nothing is stored in the DB. Depending on the type of field, this could be a <strong>blank</strong> space, the number <strong>0</strong> or for a boolean <strong>FALSE</strong>.</p><p><strong>It is strongly urged not to use this for booleans as it could lead to confusing results.</strong></p><p>Note: you can in fact disable this functionality altogether by unchecking this box. Useful when debugging tables and you need the values to the filled even though the fields have been individually selected.</p>'),
  );

  $form['storage_toggle']['webform_storage_toggle_use_textfield_replacement'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use a different string as opposed to a NULL for textfields'),
    '#default_value' => variable_get(webform_storage_toggle_use_textfield_replacement, 0),
    '#description' => t('In the very rare occasion you need some kind of different value in the textfields as opposed to a blank space or NULL value. Select this checkbox and fill in the field below'),
  );

  $form['storage_toggle']['webform_storage_toggle_obfuscation_value'] = array(
    '#type' => 'textfield',
    '#title' => t('Obfuscation value'),
    '#default_value' => variable_get('webform_storage_toggle_obfuscation_value'),
    '#description' => t('This value will be used in the replacement of submission textfield values.'),
    '#states' => array(
      'visible' => array(
        ':input[name="webform_storage_toggle_use_textfield_replacement"]' => array('checked' => TRUE),
      ),
    ),
  );

  $obfuscation_display_text = variable_get('webform_storage_toggle_obfuscation_display_text');
  $form['storage_toggle']['webform_storage_toggle_obfuscation_display_text'] = array(
    '#type' => 'textfield',
    '#title' => t('Obfuscation display text'),
    '#default_value' => isset($obfuscation_display_text) ? $obfuscation_display_text : t('n/a'),
    '#description' => t('Any fields using the obfuscation replacement will have their displayed values replaced with this text.'),
  );


}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function webform_storage_toggle_form_webform_component_edit_form_alter(&$form, $form_state) {
  // Add our fields to the component add/edit form.
  $component = $form_state['build_info']['args'][1];

  // Exclude webform component types that don't make sense to toggle.
  $excluded_types = array('fieldset', 'file', 'markup', 'pagebreak');
  if (!in_array($form['type']['#value'], $excluded_types)) {

    // Add settings for storage toggle features.
    $form['storage'] = array(
      '#type' => 'fieldset',
      '#title' => t('Field Storage Options'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#weight' => 10,
    );

    $form['storage']['db_toggle'] = array(
      '#type' => 'checkbox',
      '#title' => t('Do not store this field\'s value in the DB'),
      '#description' => t('This option will bypass the storing of this field\'s value in the DB. This ensures the data is only captured in memory and kept until the submission process is completed and all othe processing is complete. In place of the submission, a replacement value will be saved. The value may be modified in the global <a href="!url">Webform settings</a>.', array('!url' => url('admin/config/content/webform'))),
      '#default_value' => isset($component['extra']['db_toggle']) ? $component['extra']['db_toggle'] : 0,
    );
  }
}

/**
 * Implementation of hook_form_alter().
 */
function webform_storage_toggle_form_alter(&$form, &$form_state, $form_id) {
  // When we are editing a webform submission,
  if (strpos($form_id, 'webform_client_form_') === 0 && $form['details']['sid']['#value']) {
    _webform_storage_toggle_do_something_with_value($form['submitted']);
  }
}

/**
 * Implementation of hook_webform_component_presave().
 * Save db_toggle settings for a component.
 */
function webform_storage_toggle_webform_component_presave(&$component) {
  if (!empty($component['storage'])) {
    $component['extra'] = array_merge($component['extra'], $component['storage']);
    unset($component['storage']);
  }
}

/**
 * Implementation of hook_webform_submission_presave().
 * Kill the value if the component has been marked as such.
 */
function webform_storage_toggle_webform_submission_presave($node, &$submission) {
  foreach ($submission->data as $cid => $entry) {
    if (!empty($node->webform['components'][$cid]['extra']['db_toggle'])) {
      foreach ($submission->data[$cid] as $delta => $value) {
        $submission->data[$cid][$delta] = _webform_storage_toggle_kill_value();//encrypt($entry[$delta], array('base64' => TRUE));
      }
    }
  }
}

/**
 * Implementation of hook_webform_submission_load().
 * Ensure loading killed values brings up a notice for this such that results
 * do not look odd. A notice should be included in the table or cell row
 */
function webform_storage_toggle_webform_submission_load($submissions) {
  foreach ($submissions as $submission) {
    $node = node_load($submission->nid);
    foreach ($submission->data as $cid => $entry) {
      if (!empty($node->webform['components'][$cid]['extra']['db_toggle'])) {
        foreach ($submission->data[$cid] as $delta => $value) {
          if (!empty($entry[$delta]) && @unserialize($entry[$delta]) !== FALSE) {
            $submission->data[$cid][$delta] = _webform_storage_toggle_load_killed_value_notice();
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_webform_submission_render_alter().
 * Ensure loading killed values brings up a notice when displaying
 * webform submissions.
 */
function webform_storage_toggle_webform_submission_render_alter(&$renderable) {
  // First, determine if 1) if we are dealing with an email or a page view
  if (!empty($renderable['#email'])) {
    // If we are, then try to match a user to the email address we are sending to.
    $uid = db_query('SELECT uid FROM {users} WHERE mail = ?', array($renderable['#email']['email']))->fetchField();
    $account = $uid ? user_load($uid) : NULL;
  } else {
    $account = NULL;
  }

  // Next, we loop through components and bounce the values as necessary.
  _webform_storage_toggle_killed_values($renderable, '#value', array('account' => $account));
}

/**
 * Preprocess for theme('webform_results_table').
 *
 * Decrypt webform values in the table display.
 */
function webform_storage_toggle_preprocess_webform_results_table(&$vars) {
  foreach ($vars['submissions'] as $sid => &$submission) {
    foreach ($submission->data as $cid => &$item) {
      $component = $vars['components'][$cid];
      if (!empty($component['extra']['db_toggle'])) {
        foreach ($item['value'] as &$value) {
          //$value = _webform_storage_toggle_do_something_with_value();
        }
      }
    }
  }
}


/**
 * Implements hook_after_submission_obfuscation().
 *
 * Set up the data then invoke the Rules event.
 */
function webform_storage_toggle_after_submission_obfuscation($submission) {
  if (module_exists('rules')) {
    rules_invoke_event('after_submission_obfuscation', $submission);
  }
}

/**
 * Helper function to recursively decrypt values in a webform structure.
 */
function _webform_storage_toggle_killed_values(&$element, $key = '#default_value', $restrict = array()) {

  // Loop through each item and kill the value.
  foreach (element_children($element) as $name) {
    $component = &$element[$name];
    if (!empty($component['#webform_component']['extra']['db_toggle'])) {
      if (is_array($component[$key])) {
        foreach ($component[$key] as &$value) {
          $value = _webform_storage_toggle_do_something_with_value(); //$access ? decrypt($value, array('base64' => TRUE)) : t('[Value Encrypted]');
        }
      }
      else {
        $component[$key] = _webform_storage_toggle_do_something_with_value(); // decrypt($component[$key], array('base64' => TRUE)) : t('[Value Encrypted]');
      }
    }

    // Recurse if the current item has children.
    _webform_storage_toggle_killed_values($component, $key, $restrict);
  }
}

function _webform_storage_toggle_kill_value() {
  return "n/a";
}

function _webform_storage_toggle_load_killed_value_notice() {
  return t('Empty Field');
}

function _webform_storage_toggle_do_something_with_value() {
  return t('Empty Field');
}
